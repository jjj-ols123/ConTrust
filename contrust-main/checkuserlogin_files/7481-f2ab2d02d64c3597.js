!function(){try{var n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},e=(new n.Error).stack;e&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[e]="8dc7c515-515b-4932-9385-c17e6d625465",n._sentryDebugIdIdentifier="sentry-dbid-8dc7c515-515b-4932-9385-c17e6d625465")}catch(n){}}();"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7481],{58015:function(n,e,t){t.d(e,{Q1:function(){return s},XL:function(){return d},jc:function(){return m}});var a=t(53510),o=t(28894),i=t(25878),r=t(7324);let c=a.Z.schemas.list();async function l(n,e){let{projectRef:t,connectionString:a}=n,{result:o}=await (0,i.R)({projectRef:t,connectionString:a,sql:c.sql,queryKey:["schemas"]},e);return o}let s=function(n){let{projectRef:e,connectionString:t}=n,{enabled:a=!0,...i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,o.a)(r.A.schemas(e),n=>{let{signal:a}=n;return l({projectRef:e,connectionString:t},a)},{enabled:a&&void 0!==e,...i})};function d(n,e){return n.invalidateQueries(r.A.schemas(e))}function m(n,e){let{projectRef:t,connectionString:a}=e;return n.fetchQuery(r.A.schemas(t),n=>{let{signal:e}=n;return l({projectRef:t,connectionString:a},e)})}},14520:function(n,e,t){t.d(e,{C:function(){return a}});let a={list:(n,e)=>["projects",n,"entity-types",...e?[e]:[]]}},25878:function(n,e,t){t.d(e,{R:function(){return r}});var a=t(6464);t(62432);var o=t(37756),i=t(99492);async function r(n,e,t){var r,c,l;let{projectRef:s,connectionString:d,sql:m,queryKey:u,handleError:p,isRoleImpersonationEnabled:_=!1}=n;if(!s)throw Error("projectRef is required");if(new Blob([m]).size>.98*o.MB)throw Error("Query is too large to be run via the SQL Editor");let g=new Headers(t);d&&g.set("x-connection-encrypted",d);let{data:f,error:E}=await (0,a.v_)("/platform/pg-meta/{ref}/query",{signal:e,params:{header:{"x-connection-encrypted":null!=d?d:""},path:{ref:s},query:{key:null!==(c=null==u?void 0:u.filter(n=>"string"==typeof n||"number"==typeof n).join("-"))&&void 0!==c?c:""}},body:{query:m},headers:g});if(E){if(_&&"object"==typeof E&&null!==E&&"error"in E&&"formattedError"in E){let n=E,e=/LINE (\d+):/im,[,t]=null!==(l=e.exec(n.error))&&void 0!==l?l:[],a=Number(t);isNaN(a)||(n={...n,error:n.error.replace(e,"LINE ".concat(a-i.Yc,":")),formattedError:n.formattedError.replace(e,"LINE ".concat(a-i.Yc,":"))}),E=n}if(void 0!==p)return p(E);(0,a.S3)(E)}return _&&Array.isArray(f)&&(null==f?void 0:null===(r=f[0])||void 0===r?void 0:r[i.$y])===1?{result:[]}:{result:f}}t(52791)},52791:function(n,e,t){t.d(e,{M:function(){return a}});let a={query:(n,e)=>["projects",n,"query",...e],ongoingQueries:n=>["projects",n,"ongoing-queries"]}},99492:function(n,e,t){t.d(e,{$y:function(){return r},Jh:function(){return c},Wn:function(){return m},Yc:function(){return i}});var a=t(45536);function o(n,e){let t=new Date;t.setTime(t.getTime()+36e5);let o=Math.floor(t.getTime()/1e3),i=Math.floor(Date.now()/1e3);if("authenticated"===e.role){var r,c,l;if("native"===e.userType&&e.user){let t=e.user;return{aal:null!==(r=e.aal)&&void 0!==r?r:"aal1",amr:[{method:"password",timestamp:i}],app_metadata:t.raw_app_meta_data,aud:"authenticated",email:t.email,exp:o,iat:i,iss:"https://".concat(n,".supabase.co/auth/v1"),phone:t.phone,role:null!==(c=t.role)&&void 0!==c?c:e.role,session_id:(0,a.k$)(),sub:t.id,user_metadata:t.raw_user_meta_data,is_anonymous:t.is_anonymous}}if("external"===e.userType&&e.externalAuth)return{aal:null!==(l=e.aal)&&void 0!==l?l:"aal1",aud:"authenticated",exp:o,iat:i,role:"authenticated",session_id:(0,a.k$)(),sub:e.externalAuth.sub,...e.externalAuth.additionalClaims}}return{iss:"supabase",ref:n,role:e.role,iat:i,exp:o}}let i=11,r="ROLE_IMPERSONATION_NO_RESULTS";function c(n,e){var t;let{projectRef:a,role:i}=e;if(void 0===i)return n;let c="postgrest"===i.type?function(n,e){let t=o(n,e);return"\n    select set_config('role', '".concat(e.role,"', true),\n           set_config('request.jwt.claims', '").concat(JSON.stringify(t).replaceAll("'","''"),"', true),\n           set_config('request.method', 'POST', true),\n           set_config('request.path', '/impersonation-example-request-path', true),\n           set_config('request.headers', '{\"accept\": \"*/*\"}', true);\n  ").trim()}(a,i):(t=i.role,"\n    set local role '".concat(t,"';\n  "));return"\n    ".concat(c,'\n\n    -- If the users sql returns no rows, pg-meta will\n    -- fallback to returning the result of the impersonation sql.\n    select 1 as "').concat(r,'";\n\n    ').concat(n,"\n  ")}function l(n){return new TextEncoder().encode(n)}function s(n){return btoa(String.fromCharCode(...new Uint8Array("string"==typeof n?l(n):n))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function d(n,e){let t=s(l(JSON.stringify({alg:"HS256",typ:"JWT"})))+"."+s(l(JSON.stringify(n))),a=s(new Uint8Array(await window.crypto.subtle.sign({name:"HMAC"},await window.crypto.subtle.importKey("raw",l(e),{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"]),l(t))));return"".concat(t,".").concat(a)}function m(n,e,t){return d(o(n,t),e)}},53510:function(n,e,t){t.d(e,{Z:function(){return nB}});var a={};t.r(a),t.d(a,{create:function(){return D},list:function(){return w},remove:function(){return x},retrieve:function(){return O},update:function(){return U}});var o={};t.r(o),t.d(o,{create:function(){return P},list:function(){return H},pgFunctionArrayZod:function(){return $},pgFunctionCreateZod:function(){return q},pgFunctionDeleteZod:function(){return Y},pgFunctionOptionalZod:function(){return M},pgFunctionUpdateZod:function(){return W},pgFunctionZod:function(){return F},remove:function(){return J},retrieve:function(){return k},update:function(){return G}});var i=t(89140);let r='\n-- Can\'t use pg_authid here since some managed Postgres providers don\'t expose it\n-- https://github.com/supabase/postgres-meta/issues/212\n\nselect\n  r.oid as id,\n  rolname as name,\n  rolsuper as "isSuperuser",\n  rolcreatedb as "canCreateDb",\n  rolcreaterole as "canCreateRole",\n  rolinherit as "inheritRole",\n  rolcanlogin as "canLogin",\n  rolreplication as "isReplicationRole",\n  rolbypassrls as "canBypassRls",\n  (\n    select\n      count(*)\n    from\n      pg_stat_activity\n    where\n      r.rolname = pg_stat_activity.usename\n  ) as "activeConnections",\n  case when rolconnlimit = -1 then current_setting(\'max_connections\') :: int8\n       else rolconnlimit\n  end as "connectionLimit",\n  rolvaliduntil as "validUntil",\n  coalesce(r_config.role_configs, \'{}\') as config\nfrom\n  pg_roles r\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as role_configs\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(rolconfig), \'=\'))[1] as param,\n          (string_to_array(unnest(rolconfig), \'=\'))[2] as value\n        from\n          pg_roles\n      ) as _\n    group by\n      oid\n  ) r_config on r_config.oid = r.oid\n';var c=t(5394);let l=c.z.object({id:c.z.number(),name:c.z.string(),isSuperuser:c.z.boolean(),canCreateDb:c.z.boolean(),canCreateRole:c.z.boolean(),inheritRole:c.z.boolean(),canLogin:c.z.boolean(),isReplicationRole:c.z.boolean(),canBypassRls:c.z.boolean(),activeConnections:c.z.number(),connectionLimit:c.z.number(),validUntil:c.z.union([c.z.string(),c.z.null()]),config:c.z.record(c.z.string(),c.z.string())}),s=c.z.array(l),d=c.z.optional(l);function m(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name));throw Error("Must provide either id or name")}let u=["information_schema","pg_catalog","pg_toast"],p=(n,e)=>"\nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(".concat(n,")) FILTER (WHERE ").concat(e,")\n    FROM\n      ").concat(n,"\n  ),\n  '{}'\n) AS ").concat(n);function _(n,e,t){return(t&&(e=t.concat(null!=e?e:[])),null==n?void 0:n.length)?"IN (".concat(n.map(i.i0).join(","),")"):(null==e?void 0:e.length)?"NOT IN (".concat(e.map(i.i0).join(","),")"):""}function g(n,e){return"raise exception 'Cannot find ".concat(n," with: %', ").concat((0,i.i0)(e),";")}let f="\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || '.' || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE NULL\n  END AS default_value,\n  CASE\n    WHEN t.typtype = 'd' THEN CASE\n      WHEN bt.typelem <> 0 :: oid\n      AND bt.typlen = -1 THEN 'ARRAY'\n      WHEN nbt.nspname = 'pg_catalog' THEN format_type(t.typbasetype, NULL)\n      ELSE 'USER-DEFINED'\n    END\n    ELSE CASE\n      WHEN t.typelem <> 0 :: oid\n      AND t.typlen = -1 THEN 'ARRAY'\n      WHEN nt.nspname = 'pg_catalog' THEN format_type(a.atttypid, NULL)\n      ELSE 'USER-DEFINED'\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ('a', 'd') AS is_identity,\n  CASE\n    a.attidentity\n    WHEN 'a' THEN 'ALWAYS'\n    WHEN 'd' THEN 'BY DEFAULT'\n    ELSE NULL\n  END AS identity_generation,\n  a.attgenerated IN ('s') AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = 'd' AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ('r', 'p')\n    OR c.relkind IN ('v', 'f') AND pg_column_is_updatable(c.oid, a.attnum, FALSE)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = 'd'\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[1] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = 'u' AND cardinality(conkey) = 1\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[1] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, true),\n        8,\n        length(pg_get_constraintdef(pg_constraint.oid, true)) - 8\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = 'c' AND cardinality(conkey) = 1\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > 0\n  AND NOT a.attisdropped\n  AND (c.relkind IN ('r', 'v', 'm', 'f', 'p'))\n  AND (\n    pg_has_role(c.relowner, 'USAGE')\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      'SELECT, INSERT, UPDATE, REFERENCES'\n    )\n  )\n",E=c.z.object({id:c.z.string(),table_id:c.z.number(),schema:c.z.string(),table:c.z.string(),name:c.z.string(),ordinal_position:c.z.number(),data_type:c.z.string(),format:c.z.string(),is_identity:c.z.boolean(),identity_generation:c.z.string().nullable(),is_generated:c.z.boolean(),is_nullable:c.z.boolean(),is_updatable:c.z.boolean(),is_unique:c.z.boolean(),check:c.z.string().nullable(),default_value:c.z.any().nullable(),enums:c.z.array(c.z.string()),comment:c.z.string().nullable()}),b=c.z.array(E),h=c.z.optional(E);function y(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema&&n.table)return"schema = ".concat((0,i.i0)(n.schema)," AND ").concat((0,i.yR)("table")," = ").concat((0,i.i0)(n.table)," AND name = ").concat((0,i.i0)(n.name));throw Error("Must provide either id or schema, name and table")}let A="\n-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, 'USAGE')\n    or has_schema_privilege(n.oid, 'CREATE, USAGE')\n  )\n  and not pg_catalog.starts_with(n.nspname, 'pg_temp_')\n  and not pg_catalog.starts_with(n.nspname, 'pg_toast_temp_')\n",z=c.z.object({id:c.z.number(),name:c.z.string(),owner:c.z.string()}),I=c.z.array(z),v=c.z.optional(z),N=c.z.object({table_id:c.z.number(),name:c.z.string(),schema:c.z.string(),table_name:c.z.string()}),T=c.z.object({id:c.z.number(),constraint_name:c.z.string(),source_schema:c.z.string(),source_table_name:c.z.string(),source_column_name:c.z.string(),target_table_schema:c.z.string(),target_table_name:c.z.string(),target_column_name:c.z.string()}),R=c.z.object({id:c.z.number(),schema:c.z.string(),name:c.z.string(),rls_enabled:c.z.boolean(),rls_forced:c.z.boolean(),replica_identity:c.z.enum(["DEFAULT","INDEX","FULL","NOTHING"]),bytes:c.z.number(),size:c.z.string(),live_rows_estimate:c.z.number(),dead_rows_estimate:c.z.number(),comment:c.z.string().nullable(),primary_keys:c.z.array(N),relationships:c.z.array(T),columns:b.optional()}),S=c.z.array(R);function L(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name)," and ").concat((0,i.yR)("schema")," = ").concat((0,i.i0)(n.schema));throw Error("Must provide either id or name and schema")}function w(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:i=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=C({includeColumns:i}),c=_(e,t,n?void 0:u);return c&&(r+=" where schema ".concat(c)),a&&(r+=" limit ".concat(a)),o&&(r+=" offset ".concat(o)),{sql:r,zod:S}}function O(n){let e=L(n);return{sql:"".concat(C({includeColumns:!0})," where ").concat(e,";"),zod:R.optional()}}function x(n){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{cascade:!1},t=L(n);return{sql:"\n    do $$\n    declare\n        old record;\n    begin\n        with tables as (".concat(C({includeColumns:!1}),")\n        select * into old from tables where ").concat(t,";\n        if old is null then\n           ").concat(g("table",t),"\n        end if;\n        execute format('drop table %I.%I ").concat(e.cascade?"cascade":"restrict","', old.schema, old.name);\n    end\n    $$;\n    ")}}let C=n=>{let{includeColumns:e}=n;return"\n  with tables as (".concat("\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = 'd' THEN 'DEFAULT'\n    WHEN c.relreplident = 'i' THEN 'INDEX'\n    WHEN c.relreplident = 'f' THEN 'FULL'\n    ELSE 'NOTHING'\n  END AS replica_identity,\n  pg_total_relation_size(format('%I.%I', nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format('%I.%I', nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, '[]') as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    '[]'\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      table_id,\n      jsonb_agg(_pk.*) as primary_keys\n    from (\n      select\n        n.nspname as schema,\n        c.relname as table_name,\n        a.attname as name,\n        c.oid :: int8 as table_id\n      from\n        pg_index i,\n        pg_class c,\n        pg_attribute a,\n        pg_namespace n\n      where\n        i.indrelid = c.oid\n        and c.relnamespace = n.oid\n        and a.attrelid = c.oid\n        and a.attnum = any (i.indkey)\n        and i.indisprimary\n    ) as _pk\n    group by table_id\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = 'f'\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ('r', 'p')\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, 'USAGE')\n    OR has_table_privilege(\n      c.oid,\n      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'\n    )\n    OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n",")\n  ").concat(e?", columns as (".concat(f,")"):"","\n  select\n    *\n    ").concat(e?", ".concat(p("columns","columns.table_id = tables.id")):"","\n  from tables")};function D(n){let{name:e,schema:t="public",comment:a}=n;return{sql:"\ndo $$\nbegin\n  execute format('create table %I.%I ()', ".concat((0,i.i0)(t),", ").concat((0,i.i0)(e),");\n  ").concat(void 0===a?"":"\n  execute format('comment on table %I.%I is %L', ".concat((0,i.i0)(t),", ").concat((0,i.i0)(e),", ").concat((0,i.i0)(a),");"),"\nend\n$$;")}}function U(n,e){let{name:t,schema:a,rls_enabled:o,rls_forced:r,replica_identity:c,replica_identity_index:l,primary_keys:s,comment:d}=e;return{sql:"\nDO $$\nDECLARE\n  v_table record;\n  r record;\nBEGIN\n  WITH tables AS (\n    ".concat(C({includeColumns:!1}),"\n  )\n  SELECT *\n  INTO v_table\n  FROM tables\n  WHERE ").concat(L(n),";\n\n  IF v_table IS NULL THEN\n    ").concat(g("table",L(n)),"\n  END IF;\n\n  ").concat(void 0!==o?"execute format('ALTER TABLE %I.%I %s ROW LEVEL SECURITY',\n          v_table.schema, v_table.name,\n          CASE WHEN ".concat((0,i.i0)(o)," THEN 'ENABLE' ELSE 'DISABLE' END);"):"","\n\n  ").concat(void 0!==r?"execute format('ALTER TABLE %I.%I %s FORCE ROW LEVEL SECURITY',\n          v_table.schema, v_table.name,\n          CASE WHEN ".concat((0,i.i0)(r)," THEN '' ELSE 'NO' END);"):"","\n\n  ").concat(void 0!==c?"execute format('ALTER TABLE %I.%I REPLICA IDENTITY %s%s',\n          v_table.schema, v_table.name,\n          ".concat((0,i.i0)(c),",\n          CASE WHEN ").concat((0,i.i0)(c)," = 'INDEX' \n            THEN format(' USING INDEX %I', ").concat((0,i.i0)(l),")\n            ELSE '' END);"):"","\n\n  ").concat(void 0!==s?"\n    -- Drop existing primary key if any\n    FOR r IN (\n      SELECT conname\n      FROM pg_constraint\n      WHERE conrelid = format('%I.%I', v_table.schema, v_table.name)::regclass\n      AND contype = 'p'\n    ) LOOP\n      execute format('ALTER TABLE %I.%I DROP CONSTRAINT %I',\n        v_table.schema, v_table.name, r.conname);\n    END LOOP;\n\n    ".concat(s.length>0?"execute format('ALTER TABLE %I.%I ADD PRIMARY KEY (%s)',\n            v_table.schema, v_table.name,\n            ".concat((0,i.i0)(s.map(n=>n.name).join(", ")),");"):""):"","\n\n  ").concat(void 0!==d?"execute format('COMMENT ON TABLE %I.%I IS %L',\n          v_table.schema, v_table.name,\n          ".concat((0,i.i0)(d),");"):"","\n\n  ").concat(void 0!==a?"execute format('ALTER TABLE %I.%I SET SCHEMA %I',\n          v_table.schema, v_table.name,\n          ".concat((0,i.i0)(a),");"):"","\n\n  ").concat(void 0!==t?"\n      if ".concat((0,i.i0)(t)," != v_table.name then\n        execute format('ALTER TABLE %I.%I RENAME TO %I',\n            ").concat(void 0!==a?(0,i.i0)(a):"v_table.schema",",\n            v_table.name,\n            ").concat((0,i.i0)(t),");\n      end if;"):"","\nEND $$;")}}let j="\n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill('i'::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill(''::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill(false, array[pronargs - pronargdefaults]),\n      array_fill(true, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = 'f'\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = 'internal' then ''\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = 'internal' then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, '[]') as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, 0) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = 'i' then 'IMMUTABLE'\n    when f.provolatile = 's' then 'STABLE'\n    when f.provolatile = 'v' then 'VOLATILE'\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), '='))[1] as param,\n          (string_to_array(unnest(proconfig), '='))[2] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        'mode', t2.mode,\n        'name', name,\n        'type_id', type_id,\n        -- Cast null into false boolean\n        'has_default', COALESCE(has_default, false)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = 'i' then 'in'\n            when t1.mode = 'o' then 'out'\n            when t1.mode = 'b' then 'inout'\n            when t1.mode = 'v' then 'variadic'\n            else 'table'\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n",F=c.z.object({id:c.z.number(),schema:c.z.string(),name:c.z.string(),language:c.z.string(),definition:c.z.string(),complete_statement:c.z.string(),args:c.z.array(c.z.object({mode:c.z.union([c.z.literal("in"),c.z.literal("out"),c.z.literal("inout"),c.z.literal("variadic"),c.z.literal("table")]),name:c.z.string(),type_id:c.z.number(),has_default:c.z.boolean()})),argument_types:c.z.string(),identity_argument_types:c.z.string(),return_type_id:c.z.number(),return_type:c.z.string(),return_type_relation_id:c.z.union([c.z.number(),c.z.null()]),is_set_returning_function:c.z.boolean(),behavior:c.z.union([c.z.literal("IMMUTABLE"),c.z.literal("STABLE"),c.z.literal("VOLATILE")]),security_definer:c.z.boolean(),config_params:c.z.union([c.z.record(c.z.string(),c.z.string()),c.z.null()])}),$=c.z.array(F),M=c.z.optional(F);function H(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="\n    with f as (\n      ".concat(j,"\n    )\n    select\n      f.*\n    from f\n  "),r=_(e,t,n?void 0:u);return r&&(i+=" where schema ".concat(r)),a&&(i="".concat(i," limit ").concat(a)),o&&(i="".concat(i," offset ").concat(o)),{sql:i,zod:$}}function k(n){let{id:e,name:t,schema:a="public",args:o=[]}=n;if(e)return{sql:"\n      with f as (\n        ".concat(j,"\n      )\n      select\n        f.*\n      from f where id = ").concat((0,i.i0)(e),";"),zod:M};if(t&&a&&o)return{sql:"with f as (\n      ".concat(j,"\n    )\n    select\n      f.*\n    from f join pg_proc as p on id = p.oid where schema = ").concat((0,i.i0)(a)," and name = ").concat((0,i.i0)(t)," and p.proargtypes::text = ").concat(o.length?"(\n          select string_agg(type_oid::text, ' ') from (\n            select (\n              split_args.arr[\n                array_length(\n                  split_args.arr,\n                  1\n                )\n              ]::regtype::oid\n            ) as type_oid from (\n              select string_to_array(\n                unnest(\n                  array[".concat(o.map(i.i0),"]\n                ),\n                ' '\n              ) as arr\n            ) as split_args\n          ) args\n        )"):(0,i.i0)("")),zod:M};throw Error("Must provide either id or name and schema")}let q=c.z.object({name:c.z.string(),definition:c.z.string(),args:c.z.array(c.z.string()).optional(),behavior:c.z.enum(["IMMUTABLE","STABLE","VOLATILE"]).optional(),config_params:c.z.record(c.z.string(),c.z.string()).optional(),schema:c.z.string().optional(),language:c.z.string().optional(),return_type:c.z.string().optional(),security_definer:c.z.boolean().optional()});function B(n){let{name:e,schema:t,args:a,definition:o,return_type:r,language:c,behavior:l,security_definer:s,config_params:d}=n,{replace:m=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"\n    CREATE ".concat(m?"OR REPLACE":""," FUNCTION ").concat((0,i.yR)(t),".").concat((0,i.yR)(e),"(").concat((null==a?void 0:a.join(", "))||"",")\n    RETURNS ").concat(r,"\n    AS ").concat((0,i.i0)(o),"\n    LANGUAGE ").concat(c,"\n    ").concat(l,"\n    CALLED ON NULL INPUT\n    ").concat(s?"SECURITY DEFINER":"SECURITY INVOKER","\n    ").concat(d?Object.entries(d).map(n=>{let[e,t]=n;return"SET ".concat(e," ").concat("FROM CURRENT"===t?"FROM CURRENT":"TO "+('""'===t?"''":t))}).join("\n"):"",";\n  ")}function P(n){let{name:e,schema:t="public",args:a=[],definition:o,return_type:i="void",language:r="sql",behavior:l="VOLATILE",security_definer:s=!1,config_params:d={}}=n;return{sql:B({name:e,schema:t,args:a,definition:o,return_type:i,language:r,behavior:l,security_definer:s,config_params:d}),zod:c.z.void()}}let W=c.z.object({name:c.z.string().optional(),schema:c.z.string().optional(),definition:c.z.string().optional()});function G(n,e){var t;let{name:a,schema:o,definition:r}=e,l=n.argument_types.split(", "),s=n.identity_argument_types,d="string"==typeof r?B({...n,definition:r,args:l,config_params:null!==(t=n.config_params)&&void 0!==t?t:{}},{replace:!0}):"",m=a&&a!==n.name?"ALTER FUNCTION ".concat((0,i.yR)(n.schema),".").concat((0,i.yR)(n.name),"(").concat(s,") RENAME TO ").concat((0,i.yR)(a),";"):"",u=o&&o!==n.schema?"ALTER FUNCTION ".concat((0,i.yR)(n.schema),".").concat((0,i.yR)(a||n.name),"(").concat(s,")  SET SCHEMA ").concat((0,i.yR)(o),";"):"";return{sql:"\n    DO LANGUAGE plpgsql $$\n    BEGIN\n      IF ".concat("string"==typeof r?"TRUE":"FALSE"," THEN\n        ").concat(d,"\n\n        IF (\n          SELECT id\n          FROM (").concat(j,") AS f\n          WHERE f.schema = ").concat((0,i.i0)(n.schema),"\n          AND f.name = ").concat((0,i.i0)(n.name),"\n          AND f.identity_argument_types = ").concat((0,i.i0)(s),"\n        ) != ").concat(n.id," THEN\n          RAISE EXCEPTION 'Cannot find function \"").concat(n.schema,'"."').concat(n.name,'"(').concat(s,")';\n        END IF;\n      END IF;\n\n      ").concat(m,"\n\n      ").concat(u,"\n    END;\n    $$;\n  "),zod:c.z.void()}}let Y=c.z.object({cascade:c.z.boolean().default(!1).optional()});function J(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"DROP FUNCTION ".concat((0,i.yR)(n.schema),".").concat((0,i.yR)(n.name),"\n  (").concat(n.identity_argument_types,")\n  ").concat(e?"CASCADE":"RESTRICT",";"),zod:c.z.void()}}let V="\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = 'r' then 'table'\n    when c.relkind = 'v' then 'view'\n    when c.relkind = 'm' then 'materialized_view'\n    when c.relkind = 'f' then 'foreign_table'\n    when c.relkind = 'p' then 'partitioned_table'\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        'grantor', grantor.rolname,\n        'grantee', grantee.rolname,\n        'privilege_type', _priv.privilege_type,\n        'is_grantable', _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    '[]'\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault('r', c.relowner)))\n) as _priv on true\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    (0)::oid as oid, 'PUBLIC'\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ('r', 'v', 'm', 'f', 'p')\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, 'USAGE')\n    or has_table_privilege(\n      c.oid,\n      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'\n      || case when current_setting('server_version_num')::int4 >= 170000 then ', MAINTAIN' else '' end\n    )\n    or has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n",X=c.z.object({relation_id:c.z.number(),schema:c.z.string(),name:c.z.string(),kind:c.z.union([c.z.literal("table"),c.z.literal("view"),c.z.literal("materialized_view"),c.z.literal("foreign_table"),c.z.literal("partitioned_table")]),privileges:c.z.array(c.z.object({grantor:c.z.string(),grantee:c.z.string(),privilege_type:c.z.union([c.z.literal("SELECT"),c.z.literal("INSERT"),c.z.literal("UPDATE"),c.z.literal("DELETE"),c.z.literal("TRUNCATE"),c.z.literal("REFERENCES"),c.z.literal("TRIGGER"),c.z.literal("MAINTAIN")]),is_grantable:c.z.boolean()}))}),K=c.z.array(X),Z=c.z.optional(X),Q="\nSELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN NULL\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            'id',\n            c.oid :: int8,\n            'name',\n            c.relname,\n            'schema',\n            nc.nspname\n          )\n        ),\n        '{}'\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON 1 = 1\n",nn=c.z.object({id:c.z.number().optional(),name:c.z.string(),schema:c.z.string()}),ne=c.z.object({id:c.z.number(),name:c.z.string(),owner:c.z.string(),publish_insert:c.z.boolean(),publish_update:c.z.boolean(),publish_delete:c.z.boolean(),publish_truncate:c.z.boolean(),tables:c.z.array(nn).nullable()}),nt=c.z.array(ne),na=c.z.optional(ne);function no(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name));throw Error("Must provide either id or name")}let ni="\nSELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\n",nr=c.z.object({name:c.z.string(),schema:c.z.string().nullable(),default_version:c.z.string(),installed_version:c.z.string().nullable(),comment:c.z.string()}),nc=c.z.array(nr),nl=c.z.optional(nr),ns=c.z.object({name:c.z.string(),setting:c.z.string(),category:c.z.string(),group:c.z.string(),subgroup:c.z.string(),unit:c.z.string().nullable(),short_desc:c.z.string(),extra_desc:c.z.string().nullable(),context:c.z.string(),vartype:c.z.string(),source:c.z.string(),min_val:c.z.string().nullable(),max_val:c.z.string().nullable(),enumvals:c.z.array(c.z.string()).nullable(),boot_val:c.z.string().nullable(),reset_val:c.z.string().nullable(),sourcefile:c.z.string().nullable(),sourceline:c.z.number().nullable(),pending_restart:c.z.boolean()}),nd=c.z.array(ns),nm=c.z.object({id:c.z.number(),schema:c.z.string(),name:c.z.string(),is_populated:c.z.boolean(),comment:c.z.string().nullable(),columns:b.optional()}),nu=c.z.array(nm),np=c.z.optional(nm),n_=n=>{let{includeColumns:e}=n;return"\nwith materialized_views as (".concat("\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  c.relkind = 'm'\n",")\n  ").concat(e?", columns as (".concat(f,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(p("columns","columns.table_id = materialized_views.id")):"","\nfrom materialized_views")},ng=c.z.object({id:c.z.number(),schema:c.z.string(),name:c.z.string(),comment:c.z.string().nullable(),columns:b.optional()}),nf=c.z.array(ng),nE=c.z.optional(ng),nb=n=>{let{includeColumns:e}=n;return"\nwith foreign_tables as (".concat("\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  c.relkind = 'f'\n",")\n  ").concat(e?", columns as (".concat(f,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(p("columns","columns.table_id = foreign_tables.id")):"","\nfrom foreign_tables")},nh=c.z.object({id:c.z.number(),schema:c.z.string(),name:c.z.string(),is_updatable:c.z.boolean(),comment:c.z.string().nullable(),columns:b.optional()}),ny=c.z.array(nh),nA=c.z.optional(nh),nz=n=>{let{includeColumns:e}=n;return"\nwith views as (".concat("\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  (pg_relation_is_updatable(c.oid, false) & 20) = 20 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  c.relkind = 'v'\n",")\n  ").concat(e?", columns as (".concat(f,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(p("columns","columns.table_id = views.id")):"","\nfrom views")},nI="\nselect\n  pol.oid :: int8 as id,\n  n.nspname as schema,\n  c.relname as table,\n  c.oid :: int8 as table_id,\n  pol.polname as name,\n  case\n    when pol.polpermissive then 'PERMISSIVE'::text\n    else 'RESTRICTIVE'::text\n  end as action,\n  case\n    when pol.polroles = '{0}'::oid[] then array_to_json(string_to_array('public'::text, ''::text)::name[])\n    else array_to_json(array(\n      select pg_roles.rolname\n      from pg_roles\n      where pg_roles.oid = any(pol.polroles)\n      order by pg_roles.rolname\n    ))\n  end as roles,\n  case pol.polcmd\n    when 'r'::\"char\" then 'SELECT'::text\n    when 'a'::\"char\" then 'INSERT'::text\n    when 'w'::\"char\" then 'UPDATE'::text\n    when 'd'::\"char\" then 'DELETE'::text\n    when '*'::\"char\" then 'ALL'::text\n    else null::text\n  end as command,\n  pg_get_expr(pol.polqual, pol.polrelid) as definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) as check\nfrom\n  pg_policy pol\n  join pg_class c on c.oid = pol.polrelid\n  left join pg_namespace n on n.oid = c.relnamespace\n",nv=c.z.object({id:c.z.number(),schema:c.z.string(),table:c.z.string(),table_id:c.z.number(),name:c.z.string(),action:c.z.union([c.z.literal("PERMISSIVE"),c.z.literal("RESTRICTIVE")]),roles:c.z.array(c.z.string()),command:c.z.union([c.z.literal("SELECT"),c.z.literal("INSERT"),c.z.literal("UPDATE"),c.z.literal("DELETE"),c.z.literal("ALL")]),definition:c.z.union([c.z.string(),c.z.null()]),check:c.z.union([c.z.string(),c.z.null()])}),nN=c.z.array(nv),nT=c.z.optional(nv);function nR(n){if("id"in n&&n.id)return"id = ".concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema&&n.table)return"name = ".concat((0,i.i0)(n.name)," AND schema = ").concat((0,i.i0)(n.schema)," AND table = ").concat((0,i.i0)(n.table));throw Error("Must provide either id or name, schema and table")}let nS="\nSELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = 'D' THEN 'DISABLED'\n    WHEN pg_t.tgenabled = 'O' THEN 'ORIGIN'\n    WHEN pg_t.tgenabled = 'R' THEN 'REPLICA'\n    WHEN pg_t.tgenabled = 'A' THEN 'ALWAYS'\n  END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, 'escape'), '\\000'\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname\n";function nL(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.table&&n.schema)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name)," and ").concat((0,i.yR)("schema")," = ").concat((0,i.i0)(n.schema)," and ").concat((0,i.yR)("table")," = ").concat((0,i.i0)(n.table));throw Error("Must provide either id or name, schema and table")}let nw=c.z.object({id:c.z.number(),table_id:c.z.number(),enabled_mode:c.z.enum(["DISABLED","ORIGIN","REPLICA","ALWAYS"]),function_args:c.z.array(c.z.string()),name:c.z.string(),table:c.z.string(),schema:c.z.string(),condition:c.z.string().nullable(),orientation:c.z.string(),activation:c.z.string(),events:c.z.array(c.z.string()),function_name:c.z.string(),function_schema:c.z.string()}),nO=c.z.array(nw),nx=c.z.optional(nw);c.z.object({name:c.z.string(),schema:c.z.string().optional().default("public"),table:c.z.string(),function_schema:c.z.string().optional().default("public"),function_name:c.z.string(),function_args:c.z.array(c.z.string()).optional(),activation:c.z.enum(["BEFORE","AFTER","INSTEAD OF"]),events:c.z.array(c.z.string()),orientation:c.z.enum(["ROW","STATEMENT"]).optional(),condition:c.z.string().optional()}),c.z.object({name:c.z.string().optional(),enabled_mode:c.z.enum(["ORIGIN","REPLICA","ALWAYS","DISABLED"]).optional()});let nC=c.z.object({id:c.z.number(),name:c.z.string(),schema:c.z.string(),format:c.z.string(),enums:c.z.array(c.z.string()),attributes:c.z.array(c.z.object({name:c.z.string(),type_id:c.z.number()})),comment:c.z.string().nullable()}),nD=c.z.array(nC),nU=c.z.object({version:c.z.string(),version_number:c.z.number(),active_connections:c.z.number(),max_connections:c.z.number()}),nj="\n  SELECT\n    idx.indexrelid::int8 AS id,\n    idx.indrelid::int8 AS table_id,\n    n.nspname AS schema,\n    idx.indnatts AS number_of_attributes,\n    idx.indnkeyatts AS number_of_key_attributes,\n    idx.indisunique AS is_unique,\n    idx.indisprimary AS is_primary,\n    idx.indisexclusion AS is_exclusion,\n    idx.indimmediate AS is_immediate,\n    idx.indisclustered AS is_clustered,\n    idx.indisvalid AS is_valid,\n    idx.indcheckxmin AS check_xmin,\n    idx.indisready AS is_ready,\n    idx.indislive AS is_live,\n    idx.indisreplident AS is_replica_identity,\n    idx.indkey::smallint[] AS key_attributes,\n    idx.indcollation::integer[] AS collation,\n    idx.indclass::integer[] AS class,\n    idx.indoption::smallint[] AS options,\n    idx.indpred AS index_predicate,\n    obj_description(idx.indexrelid, 'pg_class') AS comment,\n    ix.indexdef as index_definition,\n    am.amname AS access_method,\n    jsonb_agg(\n      jsonb_build_object(\n        'attribute_number', a.attnum,\n        'attribute_name', a.attname,\n        'data_type', format_type(a.atttypid, a.atttypmod)\n      )\n      ORDER BY a.attnum\n    ) AS index_attributes\n  FROM\n    pg_index idx\n    JOIN pg_class c ON c.oid = idx.indexrelid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\n    JOIN pg_am am ON c.relam = am.oid\n    JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(idx.indkey)\n    JOIN pg_indexes ix ON c.relname = ix.indexname\n  GROUP BY\n    idx.indexrelid, idx.indrelid, n.nspname, idx.indnatts, idx.indnkeyatts, idx.indisunique, \n    idx.indisprimary, idx.indisexclusion, idx.indimmediate, idx.indisclustered, idx.indisvalid, \n    idx.indcheckxmin, idx.indisready, idx.indislive, idx.indisreplident, idx.indkey, \n    idx.indcollation, idx.indclass, idx.indoption, idx.indexprs, idx.indpred, ix.indexdef, am.amname\n",nF=c.z.object({id:c.z.number(),table_id:c.z.number(),schema:c.z.string(),number_of_attributes:c.z.number(),number_of_key_attributes:c.z.number(),is_unique:c.z.boolean(),is_primary:c.z.boolean(),is_exclusion:c.z.boolean(),is_immediate:c.z.boolean(),is_clustered:c.z.boolean(),is_valid:c.z.boolean(),check_xmin:c.z.boolean(),is_ready:c.z.boolean(),is_live:c.z.boolean(),is_replica_identity:c.z.boolean(),key_attributes:c.z.array(c.z.number()),collation:c.z.array(c.z.number()),class:c.z.array(c.z.number()),options:c.z.array(c.z.number()),index_predicate:c.z.string().nullable(),comment:c.z.string().nullable(),index_definition:c.z.string(),access_method:c.z.string(),index_attributes:c.z.array(c.z.object({attribute_number:c.z.number(),attribute_name:c.z.string(),data_type:c.z.string()}))}),n$=c.z.array(nF),nM=c.z.optional(nF),nH=c.z.object({grantor:c.z.string(),grantee:c.z.string(),privilege_type:c.z.union([c.z.literal("SELECT"),c.z.literal("INSERT"),c.z.literal("UPDATE"),c.z.literal("REFERENCES")]),is_grantable:c.z.boolean()}),nk=c.z.object({column_id:c.z.string(),relation_schema:c.z.string(),relation_name:c.z.string(),column_name:c.z.string(),privileges:c.z.array(nH)}),nq=c.z.array(nk);c.z.object({columnId:c.z.string(),grantee:c.z.string(),privilegeType:c.z.union([c.z.literal("ALL"),c.z.literal("SELECT"),c.z.literal("INSERT"),c.z.literal("UPDATE"),c.z.literal("REFERENCES")]),isGrantable:c.z.boolean().optional()});var nB={roles:{list:function(){let{includeDefaultRoles:n=!1,limit:e,offset:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a="\nwith\n  roles as (".concat(r,")\nselect\n  *\nfrom\n  roles\nwhere\n  true\n");return n||(a+=" and not pg_catalog.starts_with(name, 'pg_')"),e&&(a+=" limit ".concat(e)),t&&(a+=" offset ".concat(t)),{sql:a,zod:s}},retrieve:function(n){return{sql:"with roles as (".concat(r,") select * from roles where ").concat(m(n),";"),zod:d}},create:function(n){let{name:e,isSuperuser:t=!1,canCreateDb:a=!1,canCreateRole:o=!1,inheritRole:r=!0,canLogin:c=!1,isReplicationRole:l=!1,canBypassRls:s=!1,connectionLimit:d=-1,password:m,validUntil:u,memberOf:p=[],members:_=[],admins:g=[],config:f={}}=n;return{sql:"\ncreate role ".concat((0,i.yR)(e),"\n  ").concat(t?"superuser":"","\n  ").concat(a?"createdb":"","\n  ").concat(o?"createrole":"","\n  ").concat(r?"":"noinherit","\n  ").concat(c?"login":"","\n  ").concat(l?"replication":"","\n  ").concat(s?"bypassrls":"","\n  connection limit ").concat(d,"\n  ").concat(void 0===m?"":"password ".concat((0,i.i0)(m)),"\n  ").concat(void 0===u?"":"valid until ".concat((0,i.i0)(u)),"\n  ").concat(0===p.length?"":"in role ".concat(p.map(i.yR).join(",")),"\n  ").concat(0===_.length?"":"role ".concat(_.map(i.yR).join(",")),"\n  ").concat(0===g.length?"":"admin ".concat(g.map(i.yR).join(",")),"\n  ;\n").concat(Object.entries(f).map(n=>{let[t,a]=n;return"alter role ".concat((0,i.yR)(e)," set ").concat((0,i.yR)(t)," = ").concat((0,i.i0)(a),";")}).join("\n"),"\n")}},update:function(n,e){let{name:t,isSuperuser:a,canCreateDb:o,canCreateRole:c,inheritRole:l,canLogin:s,isReplicationRole:d,canBypassRls:u,connectionLimit:p,password:_,validUntil:g}=e;return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with roles as (".concat(r,")\n  select * into old from roles where ").concat(m(n),";\n  if old is null then\n    raise exception 'Cannot find role with id %', id;\n  end if;\n\n  execute(format('alter role %I\n    ").concat(void 0===a?"":a?"superuser":"nosuperuser","\n    ").concat(void 0===o?"":o?"createdb":"nocreatedb","\n    ").concat(void 0===c?"":c?"createrole":"nocreaterole","\n    ").concat(void 0===l?"":l?"inherit":"noinherit","\n    ").concat(void 0===s?"":s?"login":"nologin","\n    ").concat(void 0===d?"":d?"replication":"noreplication","\n    ").concat(void 0===u?"":u?"bypassrls":"nobypassrls","\n    ").concat(void 0===p?"":"connection limit ".concat(p),"\n    ").concat(void 0===_?"":"password ".concat((0,i.i0)(_)),"\n    ").concat(void 0===g?"":"valid until %L","\n  ', old.name").concat(void 0===g?"":", ".concat((0,i.i0)(g)),"));\n\n  ").concat(void 0===t?"":"\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if ".concat((0,i.i0)(t)," != old.name then\n    execute(format('alter role %I rename to %I;', old.name, ").concat((0,i.i0)(t),"));\n  end if;\n  "),"\nend\n$$;\n")}},remove:function(n){let{ifExists:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with roles as (".concat(r,")\n  select * into old from roles where ").concat(m(n),";\n  if old is null then\n    raise exception 'Cannot find role with id %', id;\n  end if;\n\n  execute(format('drop role ").concat(e?"if exists":""," %I;', old.name));\nend\n$$;\n")}},zod:l},columns:{list:function(){let{tableId:n,includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:a,limit:o,offset:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\nwith\n  columns as (".concat(f,")\nselect\n  *\nfrom\n  columns\nwhere\n true\n"),l=_(t,a,e?void 0:u);return l&&(c+=" and schema ".concat(l)),void 0!==n&&(c+=" and table_id = ".concat((0,i.i0)(n)," ")),o&&(c="".concat(c," limit ").concat(o)),r&&(c="".concat(c," offset ").concat(r)),{sql:c,zod:b}},retrieve:function(n){return{sql:"WITH columns AS (".concat(f,") SELECT * FROM columns WHERE ").concat(y(n),";"),zod:h}},create:function(n){let{table_id:e,name:t,type:a,default_value:o,default_value_format:r="literal",is_identity:c=!1,identity_generation:l="BY DEFAULT",is_nullable:s,is_primary_key:d=!1,is_unique:m=!1,comment:u,check:p}=n,_="";if(c){if(void 0!==o)throw Error("Columns cannot both be identity and have a default value");_="GENERATED ".concat(l," AS IDENTITY")}else if(void 0!==o){let n="expression"===r?o:"'".concat((0,i.i0)(String(o)),"'");_="DEFAULT ".concat(n)}let g=[];return!1===s&&g.push("NOT NULL"),d&&g.push("PRIMARY KEY"),m&&g.push("UNIQUE"),p&&g.push("CHECK (".concat(p,")")),{sql:"\nDO $$\nDECLARE\n  v_schema name;\n  v_table name;\nBEGIN\n  SELECT n.nspname, c.relname INTO v_schema, v_table\n  FROM pg_class c \n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.oid = ".concat((0,i.i0)(e),";\n\n  IF v_schema IS NULL THEN\n    RAISE EXCEPTION 'Table with id % not found', ").concat((0,i.i0)(e),";\n  END IF;\n\n  execute(format(\n    'ALTER TABLE %I.%I ADD COLUMN %I %s ").concat(_," ").concat(g.join(" "),"',\n    v_schema,\n    v_table,\n    ").concat((0,i.i0)(t),",\n    ").concat((0,i.i0)(a),"\n  ));\n  \n  ").concat(u?"execute(format('COMMENT ON COLUMN %I.%I.%I IS %L', v_schema, v_table, ".concat((0,i.i0)(t),", quote_ident(").concat((0,i.i0)(u),")));"):"","\nEND $$;")}},update:function(n,e){let{name:t,type:a,drop_default:o=!1,default_value:r,default_value_format:c="literal",is_identity:l,identity_generation:s="BY DEFAULT",is_nullable:d,is_unique:m,comment:u,check:p}=e;if(l&&void 0!==r)throw Error("Columns cannot both be identity and have a default value");return{sql:"\nDO $$\nDECLARE\n  v_schema name;\n  v_table name;\n  v_column name;\n  v_attnum int2;\n  r record;\nBEGIN\n  WITH RECURSIVE column_info AS (\n    ".concat(f,"\n  )\n  SELECT \n    schema, \n    ").concat((0,i.yR)("table"),",\n    name,\n    ordinal_position::int2\n  INTO v_schema, v_table, v_column, v_attnum\n  FROM column_info \n  WHERE ").concat(y({id:n}),";\n\n  IF v_schema IS NULL THEN\n    RAISE EXCEPTION 'Column with id % not found', ").concat((0,i.i0)(n),";\n  END IF;\n\n  ").concat(void 0!==d?"execute(format('ALTER TABLE %I.%I ALTER COLUMN %I ".concat(d?"DROP NOT NULL":"SET NOT NULL","', v_schema, v_table, v_column));"):"","\n\n  ").concat(a?"execute(format('ALTER TABLE %I.%I ALTER COLUMN %I TYPE %I USING %I::%I', v_schema, v_table, v_column, ".concat((0,i.i0)(a),", v_column, ").concat((0,i.i0)(a),"));"):"","\n\n  ").concat(o?"execute(format('ALTER TABLE %I.%I ALTER COLUMN %I DROP DEFAULT', v_schema, v_table, v_column));":"","\n\n  ").concat(void 0!==r?"execute(format('ALTER TABLE %I.%I ALTER COLUMN %I SET DEFAULT %s', v_schema, v_table, v_column, ".concat("expression"===c?r:(0,i.i0)(r),"));"):"","\n  \n  ").concat(void 0!==l?"execute(format('ALTER TABLE %I.%I ALTER COLUMN %I ".concat(l?"ADD GENERATED ".concat(s," AS IDENTITY"):"DROP IDENTITY IF EXISTS","', v_schema, v_table, v_column));"):"","\n  \n  ").concat(void 0!==m?"execute(format('ALTER TABLE %I.%I ".concat(m?"ADD UNIQUE":"DROP CONSTRAINT IF EXISTS %I_key","', v_schema, v_table, ").concat(m?"(".concat((0,i.i0)(t||"v_column"),")"):"v_column","));"):"","\n\n  ").concat(void 0!==u?"execute(format('COMMENT ON COLUMN %I.%I.%I IS %L', v_schema, v_table, v_column, ".concat((0,i.i0)(u),"));"):"","\n\n  ").concat(void 0!==p?"\n    -- Drop existing check constraint if any\n    FOR r IN (\n      SELECT conname \n      FROM pg_constraint \n      WHERE conrelid = format('%I.%I', v_schema, v_table)::regclass \n      AND contype = 'c' \n      AND conkey = ARRAY[v_attnum]\n    ) LOOP\n      EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %I', v_schema, v_table, r.conname);\n    END LOOP;\n    -- Create the new constraints if mentionned\n    ".concat(null!==p?"execute(format('ALTER TABLE %I.%I ADD CONSTRAINT %I CHECK (%s)', v_schema, v_table, v_column || '_check', ".concat((0,i.i0)(p),"));"):"","\n  "):"","\n  ").concat(t?"execute(format('ALTER TABLE %I.%I RENAME COLUMN %I TO %I', v_schema, v_table, v_column, ".concat((0,i.i0)(t),"));"):"","\nEND $$;")}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\nDO $$\nDECLARE\n  v_schema name;\n  v_table name;\n  v_column name;\nBEGIN\n  WITH RECURSIVE column_info AS (\n    ".concat(f,"\n  )\n  SELECT schema, ").concat((0,i.yR)("table"),", name\n  INTO v_schema, v_table, v_column\n  FROM column_info \n  WHERE id = ").concat((0,i.i0)(n),";\n\n  IF v_schema IS NULL THEN\n    RAISE EXCEPTION 'Column with id % not found', ").concat((0,i.i0)(n),";\n  END IF;\n\n  EXECUTE format(\n    'ALTER TABLE %I.%I DROP COLUMN %I ").concat(e?"CASCADE":"RESTRICT","',\n    v_schema,\n    v_table,\n    v_column\n  );\nEND $$;")}},zod:E},schemas:{list:function(){let{includeSystemSchemas:n=!1,limit:e,offset:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=A;return n||(a="".concat(a," and not (n.nspname in (").concat(u.map(i.i0).join(","),"))")),e&&(a="".concat(a," limit ").concat(e)),t&&(a="".concat(a," offset ").concat(t)),{sql:a,zod:I}},retrieve:function(n){let{id:e,name:t}=n;return e?{sql:"".concat(A," and n.oid = ").concat((0,i.i0)(e),";"),zod:v}:{sql:"".concat(A," and n.nspname = ").concat((0,i.i0)(t),";"),zod:v}},create:function(n){let{name:e,owner:t}=n;return{sql:"create schema ".concat((0,i.yR)(e),"\n  ").concat(void 0===t?"":"authorization ".concat((0,i.yR)(t)),";\n")}},update:function(n,e){let{id:t,name:a}=n,{name:o,owner:r}=e;return{sql:"\ndo $$\ndeclare\n  id oid := ".concat(void 0===t?"".concat((0,i.i0)(a),"::regnamespace"):(0,i.i0)(t),";\n  old record;\n  new_name text := ").concat(void 0===o?null:(0,i.i0)(o),";\n  new_owner text := ").concat(void 0===r?null:(0,i.i0)(r),";\nbegin\n  select * into old from pg_namespace where oid = id;\n  if old is null then\n    raise exception 'Cannot find schema with id %', id;\n  end if;\n\n  if new_owner is not null then\n    execute(format('alter schema %I owner to %I;', old.nspname, new_owner));\n  end if;\n\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if new_name is not null and new_name != old.nspname then\n    execute(format('alter schema %I rename to %I;', old.nspname, new_name));\n  end if;\nend\n$$;\n")}},remove:function(n){let{id:e,name:t}=n,{cascade:a=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\ndo $$\ndeclare\n  id oid := ".concat(void 0===e?"".concat((0,i.i0)(t),"::regnamespace"):(0,i.i0)(e),";\n  old record;\n  cascade bool := ").concat((0,i.i0)(a),";\nbegin\n  select * into old from pg_namespace where oid = id;\n  if old is null then\n    raise exception 'Cannot find schema with id %', id;\n  end if;\n\n  execute(format('drop schema %I %s;', old.nspname, case when cascade then 'cascade' else 'restrict' end));\nend\n$$;\n")}},zod:z},tables:a,functions:o,tablePrivileges:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="\nwith table_privileges as (".concat(V,")\nselect *\nfrom table_privileges\n"),r=_(e,t,n?void 0:u);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:K}},retrieve:function(n){let{id:e,name:t,schema:a="public"}=n;return e?{sql:"\nwith table_privileges as (".concat(V,")\nselect *\nfrom table_privileges\nwhere table_privileges.relation_id = ").concat((0,i.i0)(e),";"),zod:Z}:{sql:"\nwith table_privileges as (".concat(V,")\nselect *\nfrom table_privileges\nwhere table_privileges.schema = ").concat((0,i.i0)(a),"\n  and table_privileges.name = ").concat((0,i.i0)(t),"\n"),zod:Z}},grant:function(n){return{sql:"\ndo $$\nbegin\n".concat(n.map(n=>{let{privilegeType:e,relationId:t,grantee:a,isGrantable:o}=n;return"execute format('grant ".concat(e," on table %s to ").concat("public"===a.toLowerCase()?"public":(0,i.yR)(a)," ").concat(o?"with grant option":"","', ").concat(t,"::regclass);")}).join("\n"),"\nend $$;\n")}},revoke:function(n){return{sql:"\ndo $$\nbegin\n".concat(n.map(n=>{let{privilegeType:e,relationId:t,grantee:a}=n;return"execute format('revoke ".concat(e," on table %s from ").concat("public"===a.toLowerCase()?"public":(0,i.yR)(a),"', ").concat(t,"::regclass);")}).join("\n"),"\nend $$;\n")}},zod:X},publications:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t="with publications as (".concat(Q,") select * from publications");return n&&(t+=" limit ".concat(n)),e&&(t+=" offset ".concat(e)),{sql:t,zod:nt}},retrieve:function(n){return{sql:"with publications as (".concat(Q,") select * from publications where ").concat(no(n),";"),zod:na}},create:function(n){let e,{name:t,publish_insert:a=!1,publish_update:o=!1,publish_delete:r=!1,publish_truncate:c=!1,tables:l=null}=n;e=null==l?"FOR ALL TABLES":0===l.length?"":"FOR TABLE ".concat(l.map(n=>{if(!n.includes("."))return(0,i.yR)(n);let[e,...t]=n.split("."),a=t.join(".");return"".concat((0,i.yR)(e),".").concat((0,i.yR)(a))}).join(","));let s=[...a?["insert"]:[],...o?["update"]:[],...r?["delete"]:[],...c?["truncate"]:[]];return{sql:"CREATE PUBLICATION ".concat((0,i.yR)(t)," ").concat(e," WITH (publish = '").concat(s.join(","),"');")}},update:function(n,e){var t,a,o,r;return{sql:"\ndo $$\ndeclare\n  old record;\n  new_name text := ".concat(void 0===e.name?null:(0,i.i0)(e.name),";\n  new_owner text := ").concat(void 0===e.owner?null:(0,i.i0)(e.owner),";\n  new_publish_insert bool := ").concat(null!==(t=e.publish_insert)&&void 0!==t?t:null,";\n  new_publish_update bool := ").concat(null!==(a=e.publish_update)&&void 0!==a?a:null,";\n  new_publish_delete bool := ").concat(null!==(o=e.publish_delete)&&void 0!==o?o:null,";\n  new_publish_truncate bool := ").concat(null!==(r=e.publish_truncate)&&void 0!==r?r:null,";\n  new_tables text := ").concat(void 0===e.tables?null:(0,i.i0)(null===e.tables?"all tables":e.tables.map(n=>{if(!n.includes("."))return(0,i.yR)(n);let[e,...t]=n.split("."),a=t.join(".");return"".concat((0,i.yR)(e),".").concat((0,i.yR)(a))}).join(", ")),";\nbegin\n  with publications as (").concat(Q,")\n  select * into old from publications where ").concat(no(n),";\n  if old is null then\n    raise exception 'Cannot find publication with %', ").concat((0,i.i0)(no(n)),";\n  end if;\n  if new_tables is null then\n    null;\n  elsif new_tables = 'all tables' AND old.tables is not null then\n      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.\n      execute(format('drop publication %1$I; create publication %1$I for all tables;', old.name));\n  else\n    if old.tables is null then\n      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.\n      execute(format('drop publication %1$I; create publication %1$I;', old.name));\n    elsif exists(select from pg_publication_rel where prpubid = old.id) then\n      execute(\n        format(\n          'alter publication %I drop table %s',\n          old.name,\n          (select string_agg(prrelid::regclass::text, ', ') from pg_publication_rel where prpubid = old.id)\n        )\n      );\n    end if;\n\n    -- At this point the publication must have no tables.\n    if new_tables != '' then\n      execute(format('alter publication %I add table %s', old.name, new_tables));\n    end if;\n  end if;\n\n  execute(\n    format(\n      'alter publication %I set (publish = %L);',\n      old.name,\n      concat_ws(\n        ', ',\n        case when coalesce(new_publish_insert, old.publish_insert) then 'insert' end,\n        case when coalesce(new_publish_update, old.publish_update) then 'update' end,\n        case when coalesce(new_publish_delete, old.publish_delete) then 'delete' end,\n        case when coalesce(new_publish_truncate, old.publish_truncate) then 'truncate' end\n      )\n    )\n  );\n\n  if new_owner is not null then\n    execute(format('alter publication %I owner to %I;', old.name, new_owner));\n  end if;\n\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if new_name is not null and new_name != old.name then\n    execute(format('alter publication %I rename to %I;', old.name, new_name));\n  end if;\nend $$;")}},remove:function(n){return{sql:"\n    do $$\n    declare\n      v_name name;\n    begin\n      with publications as (".concat(Q,")\n      select name into v_name from publications where ").concat(no(n),";\n      if v_name is not null then\n            execute(format('drop publication if exists %I', v_name));\n      end if;\n    end\n    $$;\n    ")}},zod:ne},extensions:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=ni;return n&&(t="".concat(t," LIMIT ").concat(n)),e&&(t="".concat(t," OFFSET ").concat(e)),{sql:t,zod:nc}},retrieve:function(n){let{name:e}=n;return{sql:"".concat(ni," WHERE name = ").concat((0,i.i0)(e),";"),zod:nl}},create:function(n){let{name:e,schema:t,version:a,cascade:o=!1}=n;return{sql:"\ndo $$\nbegin\n  -- Check if extension exists\n  if exists (\n    select 1 from pg_extension where extname = ".concat((0,i.i0)(e),"\n  ) then\n    raise exception 'Extension % already exists', ").concat((0,i.i0)(e),";\n  end if;\n\n  execute(format('CREATE EXTENSION %I\n    %s\n    %s\n    %s',\n    ").concat((0,i.i0)(e),",\n    ").concat(t?"'SCHEMA ' || quote_ident(".concat((0,i.i0)(t),")"):"''",",\n    ").concat(a?"'VERSION ' || quote_ident(".concat((0,i.i0)(a),")"):"''",",\n    ").concat(o?"'CASCADE'":"''","\n));\nend\n$$;")}},update:function(n,e){let{update:t=!1,version:a,schema:o}=e;return{sql:"\ndo $$\ndeclare\n  ext record;\nbegin\n  -- Check if extension exists\n  select * into ext from pg_extension where extname = ".concat((0,i.i0)(n),";\n  if ext is null then\n    raise exception 'Extension % does not exist', ").concat((0,i.i0)(n),";\n  end if;\n\n  ").concat(t?"execute(format('ALTER EXTENSION %I UPDATE %s',\n    ".concat((0,i.i0)(n),",\n    ").concat(a?"'TO ' || quote_ident(".concat((0,i.i0)(a),")"):"''","\n  ));"):"","\n\n  ").concat(o?"execute(format('ALTER EXTENSION %I SET SCHEMA %I',\n    ".concat((0,i.i0)(n),",\n    ").concat((0,i.i0)(o),"\n  ));"):"","\nend\n$$;")}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\ndo $$\ndeclare\n  ext record;\nbegin\n    execute(format('DROP EXTENSION %I %s',\n      ".concat((0,i.i0)(n),",\n      ").concat(e?"'CASCADE'":"'RESTRICT'","\n    ));\nend\n$$;")}},zod:nr},config:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t="\nSELECT\n  name,\n  setting,\n  category,\n  TRIM(split_part(category, '/', 1)) AS group,\n  TRIM(split_part(category, '/', 2)) AS subgroup,\n  unit,\n  short_desc,\n  extra_desc,\n  context,\n  vartype,\n  source,\n  min_val,\n  max_val,\n  enumvals,\n  boot_val,\n  reset_val,\n  sourcefile,\n  sourceline,\n  pending_restart\nFROM\n  pg_settings\nORDER BY\n  category,\n  name\n";return n&&(t+=" LIMIT ".concat(n)),e&&(t+=" OFFSET ".concat(e)),{sql:t,zod:nd}},zod:ns},materializedViews:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:i=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=n_({includeColumns:i}),c=_(e,t,n?void 0:u);return c&&(r+=" where schema ".concat(c)),a&&(r+=" limit ".concat(a)),o&&(r+=" offset ".concat(o)),{sql:r,zod:nu}},retrieve:function(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name)," and ").concat((0,i.yR)("schema")," = ").concat((0,i.i0)(n.schema));throw Error("Must provide either id or name and schema")}(n);return{sql:"".concat(n_({includeColumns:!0})," where ").concat(e,";"),zod:np}},zod:nm},foreignTables:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:i=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=nb({includeColumns:i}),c=_(e,t,n?void 0:u);return c&&(r+=" where schema ".concat(c)),a&&(r+=" limit ".concat(a)),o&&(r+=" offset ".concat(o)),{sql:r,zod:nf}},retrieve:function(n){return{sql:"".concat(nb({includeColumns:!0})," where ").concat(function(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name)," and ").concat((0,i.yR)("schema")," = ").concat((0,i.i0)(n.schema));throw Error("Must provide either id or name and schema")}(n),";"),zod:nE}},zod:ng},views:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:i=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=nz({includeColumns:i}),c=_(e,t,n?void 0:u);return c&&(r+=" where schema ".concat(c)),a&&(r+=" limit ".concat(a)),o&&(r+=" offset ".concat(o)),{sql:r,zod:ny}},retrieve:function(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,i.yR)("id")," = ").concat((0,i.i0)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,i.yR)("name")," = ").concat((0,i.i0)(n.name)," and ").concat((0,i.yR)("schema")," = ").concat((0,i.i0)(n.schema));throw Error("Must provide either id or name and schema")}(n);return{sql:"".concat(nz({includeColumns:!0})," where ").concat(e,";"),zod:nA}},zod:nh},policies:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="\n    with policies as (".concat(nI,")\n    select *\n    from policies\n    "),r=_(e,t,n?void 0:u);return r&&(i+="where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:nN}},retrieve:function(n){return{sql:"with policies as (".concat(nI,") select * from policies where ").concat(nR(n),";"),zod:nT}},create:function(n){let{name:e,schema:t="public",table:a,definition:o,check:r,action:c="PERMISSIVE",command:l="ALL",roles:s=["public"]}=n;return{sql:"\ncreate policy ".concat((0,i.yR)(e)," on ").concat((0,i.yR)(t),".").concat((0,i.yR)(a),"\n  as ").concat(c,"\n  for ").concat(l,"\n  to ").concat(s.map(i.yR).join(","),"\n  ").concat(o?"using (".concat(o,")"):"","\n  ").concat(r?"with check (".concat(r,")"):"",";")}},update:function(n,e){let{name:t,definition:a,check:o,roles:r}=e,c=nR(n);return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with policies as (".concat(nI,")\n  select * into old from policies where ").concat(c,";\n  if old is null then\n    raise exception 'Cannot find policy with id %', ").concat((0,i.i0)(c),";\n  end if;\n\n  ").concat(a?"execute(format('alter policy %I on %I.%I using (%s);', old.name, old.schema, old.table, ".concat((0,i.i0)(a),"));"):"","\n  ").concat(o?"execute(format('alter policy %I on %I.%I with check (%s);', old.name, old.schema, old.table, ".concat((0,i.i0)(o),"));"):"","\n  ").concat(r?"execute(format('alter policy %I on %I.%I to %s;', old.name, old.schema, old.table, ".concat((0,i.i0)(r.map(i.yR).join(",")),"));"):"","\n  ").concat(t?"execute(format('alter policy %I on %I.%I rename to %I;', old.name, old.schema, old.table, ".concat((0,i.i0)(t),"));"):"","\nend\n$$;")}},remove:function(n){let e=nR(n);return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with policies as (".concat(nI,")\n  select * into old from policies where ").concat(e,";\n  if old is null then\n    raise exception 'Cannot find policy with id %', ").concat((0,i.i0)(e),";\n  end if;\n\n  execute(format('drop policy %I on %I.%I;', old.name, old.schema, old.table));\nend\n$$;")}},zod:nv},triggers:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="with triggers as (".concat(nS,") select * from triggers"),r=_(e,t,n?void 0:u);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:nO}},retrieve:function(n){let e=nL(n);return{sql:"with triggers as (".concat(nS,") select * from triggers where ").concat(e,";"),zod:nx}},create:function(n){let{name:e,schema:t="public",table:a,function_schema:o="public",function_name:r,function_args:l=[],activation:s,events:d,orientation:m,condition:u}=n,p="".concat((0,i.yR)(t),".").concat((0,i.yR)(a)),_="".concat((0,i.yR)(o),".").concat((0,i.yR)(r)),g=d.join(" OR "),f=l.map(i.i0).join(",");return{sql:"CREATE TRIGGER ".concat((0,i.yR)(e)," ").concat(s," ").concat(g," ON ").concat(p," ").concat(m?"FOR EACH ".concat(m):""," ").concat(u?"WHEN (".concat(u,")"):""," EXECUTE FUNCTION ").concat(_,"(").concat(f,");"),zod:c.z.void()}},update:function(n,e){let t=nL(n);return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with triggers as (".concat(nS,")\n  select * into old from triggers where ").concat(t,";\n  \n  if old is null then\n    raise exception 'Cannot find trigger: %', ").concat((0,i.i0)(t),";\n  end if;\n\n  ").concat(e.enabled_mode?"\n  execute(format('alter table %I.%I ".concat("DISABLED"===e.enabled_mode?"DISABLE":"ENABLE"+("ALWAYS"===e.enabled_mode||"REPLICA"===e.enabled_mode?" "+e.enabled_mode:"")," TRIGGER %I', \n    old.schema, old.table, old.name));"):"","\n\n  ").concat(e.name?"\n    -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if ".concat((0,i.i0)(e.name)," != old.name then\n    execute(format('alter trigger %I on %I.%I rename to %I;', old.name, old.schema, old.table, ").concat((0,i.i0)(e.name),"));\n  end if;"):"","\nend\n$$;")}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=nL(n);return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with triggers as (".concat(nS,")\n  select * into old from triggers where ").concat(t,";\n  \n  if old is null then\n    raise exception 'Cannot find trigger';\n  end if;\n\n  execute(format('DROP TRIGGER %I ON %I.%I ").concat(e?"CASCADE":"","',\n    old.name, old.schema, old.table));\nend\n$$;"),zod:c.z.void()}},zod:nw},types:{list:function(){let{includeArrayTypes:n=!1,includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:a,limit:o,offset:i}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r="\nselect\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, null) as format,\n  coalesce(t_enums.enums, '[]') as enums,\n  coalesce(t_attributes.attributes, '[]') as attributes,\n  obj_description (t.oid, 'pg_type') as comment\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object('name', a.attname, 'type_id', a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = 'c' and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\nwhere\n  (\n    t.typrelid = 0\n    or (\n      select\n        c.relkind = 'c'\n      from\n        pg_class c\n      where\n        c.oid = t.typrelid\n    )\n  )\n";n||(r+=" and not exists (\n      select from pg_type el\n      where el.oid = t.typelem\n        and el.typarray = t.oid\n    )");let c=_(t,a,e?void 0:u);return c&&(r+=" and n.nspname ".concat(c)),o&&(r+=" limit ".concat(o)),i&&(r+=" offset ".concat(i)),{sql:r,zod:nD}},zod:nC},version:{retrieve:function(){return{sql:"\nselect\n  version(),\n  current_setting('server_version_num')::int8 as version_number,\n  (\n    select\n      count(*) as active_connections\n    from\n      pg_stat_activity\n  ) as active_connections,\n  current_setting('max_connections')::int8 as max_connections\n",zod:nU}},zod:nU},indexes:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="\n    with indexes as (".concat(nj,")\n    select *\n    from indexes\n  "),r=_(e,t,n?void 0:u);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:n$}},retrieve:function(n){let{id:e}=n;return{sql:"\n    with indexes as (".concat(nj,")\n    select *\n    from indexes\n    where id = ").concat((0,i.i0)(e),";\n  "),zod:nM}},zod:nF},columnPrivileges:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,columnIds:a,limit:o,offset:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\n  with column_privileges as (".concat("\n-- Lists each column's privileges in the form of:\n--\n-- [\n--   {\n--     \"column_id\": \"12345.1\",\n--     \"relation_schema\": \"public\",\n--     \"relation_name\": \"mytable\",\n--     \"column_name\": \"mycolumn\",\n--     \"privileges\": [\n--       {\n--         \"grantor\": \"postgres\",\n--         \"grantee\": \"myrole\",\n--         \"privilege_type\": \"SELECT\",\n--         \"is_grantable\": false\n--       },\n--       ...\n--     ]\n--   },\n--   ...\n-- ]\n--\n-- Modified from information_schema.column_privileges. We try to be as close as\n-- possible to the view definition, obtained from:\n--\n-- select pg_get_viewdef('information_schema.column_privileges');\n--\n-- The main differences are:\n-- - we include column privileges for materialized views\n--   (reason for exclusion in information_schema.column_privileges:\n--    https://www.postgresql.org/message-id/9136.1502740844%40sss.pgh.pa.us)\n-- - we query a.attrelid and a.attnum to generate column_id\n-- - table_catalog is omitted\n-- - table_schema -> relation_schema, table_name -> relation_name\n--\n-- Column privileges are intertwined with table privileges in that table\n-- privileges override column privileges. E.g. if we do:\n--\n-- grant all on mytable to myrole;\n--\n-- Then myrole is granted privileges for ALL columns. Likewise, if we do:\n--\n-- grant all (id) on mytable to myrole;\n-- revoke all on mytable from myrole;\n--\n-- Then the grant on the id column is revoked.\n--\n-- This is unlike how grants for schemas and tables interact, where you need\n-- privileges for BOTH the schema the table is in AND the table itself in order\n-- to access the table.\n\nselect (x.attrelid || '.' || x.attnum) as column_id,\n       nc.nspname as relation_schema,\n       x.relname as relation_name,\n       x.attname as column_name,\n       coalesce(\n         jsonb_agg(\n           jsonb_build_object(\n             'grantor', u_grantor.rolname,\n             'grantee', grantee.rolname,\n             'privilege_type', x.prtype,\n             'is_grantable', x.grantable\n           )\n         ),\n         '[]'\n       ) as privileges\nfrom\n  (select pr_c.grantor,\n          pr_c.grantee,\n          a.attrelid,\n          a.attnum,\n          a.attname,\n          pr_c.relname,\n          pr_c.relnamespace,\n          pr_c.prtype,\n          pr_c.grantable,\n          pr_c.relowner\n   from\n     (select pg_class.oid,\n             pg_class.relname,\n             pg_class.relnamespace,\n             pg_class.relowner,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantor as grantor,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantee as grantee,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).privilege_type as privilege_type,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).is_grantable as is_grantable\n      from pg_class\n      where (pg_class.relkind = any (array['r',\n                                           'v',\n                                           'm',\n                                           'f',\n                                           'p'])) ) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),\n                                                    pg_attribute a\n   where ((a.attrelid = pr_c.oid)\n          and (a.attnum > 0)\n          and (not a.attisdropped))\n   union select pr_a.grantor,\n                pr_a.grantee,\n                pr_a.attrelid,\n                pr_a.attnum,\n                pr_a.attname,\n                c.relname,\n                c.relnamespace,\n                pr_a.prtype,\n                pr_a.grantable,\n                c.relowner\n   from\n     (select a.attrelid,\n             a.attnum,\n             a.attname,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantor as grantor,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantee as grantee,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).privilege_type as privilege_type,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).is_grantable as is_grantable\n      from (pg_attribute a\n            join pg_class cc on ((a.attrelid = cc.oid)))\n      where ((a.attnum > 0)\n             and (not a.attisdropped))) pr_a(attrelid, attnum, attname, grantor, grantee, prtype, grantable),\n                                        pg_class c\n   where ((pr_a.attrelid = c.oid)\n          and (c.relkind = any (ARRAY['r',\n                                      'v',\n                                      'm',\n                                      'f',\n                                      'p'])))) x,\n     pg_namespace nc,\n     pg_authid u_grantor,\n  (select pg_authid.oid,\n          pg_authid.rolname\n   from pg_authid\n   union all select (0)::oid as oid,\n                    'PUBLIC') grantee(oid, rolname)\nwhere ((x.relnamespace = nc.oid)\n       and (x.grantee = grantee.oid)\n       and (x.grantor = u_grantor.oid)\n       and (x.prtype = any (ARRAY['INSERT',\n                                  'SELECT',\n                                  'UPDATE',\n                                  'REFERENCES']))\n       and (pg_has_role(u_grantor.oid, 'USAGE')\n            or pg_has_role(grantee.oid, 'USAGE')\n            or (grantee.rolname = 'PUBLIC')))\ngroup by column_id,\n         nc.nspname,\n         x.relname,\n         x.attname\n",")\n  select *\n  from column_privileges\n  "),l=[],s=_(e,t,n?void 0:u);return s&&l.push("relation_schema ".concat(s)),(null==a?void 0:a.length)&&l.push("column_id in (".concat(a.map(i.i0).join(","),")")),l.length>0&&(c+=" where ".concat(l.join(" and "))),o&&(c+=" limit ".concat(o)),r&&(c+=" offset ".concat(r)),{sql:c,zod:nq}},grant:function(n){return{sql:"\ndo $$\ndeclare\n  col record;\nbegin\n".concat(n.map(n=>{let{privilegeType:e,columnId:t,grantee:a,isGrantable:o}=n,[r,c]=t.split(".");return"\nselect *\nfrom pg_attribute a\nwhere a.attrelid = ".concat((0,i.i0)(r),"\n  and a.attnum = ").concat((0,i.i0)(c),"\ninto col;\nexecute format(\n  'grant ").concat(e," (%I) on %s to ").concat("public"===a.toLowerCase()?"public":(0,i.yR)(a)," ").concat(o?"with grant option":"","',\n  col.attname,\n  col.attrelid::regclass\n);")}).join("\n"),"\nend $$;\n")}},revoke:function(n){return{sql:"\ndo $$\ndeclare\n  col record;\nbegin\n".concat(n.map(n=>{let{privilegeType:e,columnId:t,grantee:a}=n,[o,r]=t.split(".");return"\nselect *\nfrom pg_attribute a\nwhere a.attrelid = ".concat((0,i.i0)(o),"\n  and a.attnum = ").concat((0,i.i0)(r),"\ninto col;\nexecute format(\n  'revoke ").concat(e," (%I) on %s from ").concat("public"===a.toLowerCase()?"public":(0,i.yR)(a),"',\n  col.attname,\n  col.attrelid::regclass\n);")}).join("\n"),"\nend $$;\n")}},zod:nk}}},89140:function(n,e,t){t.d(e,{WU:function(){return l},yR:function(){return r},i0:function(){return c}});let a=new Set(["AES128","AES256","ALL","ALLOWOVERWRITE","ANALYSE","ANALYZE","AND","ANY","ARRAY","AS","ASC","ASYMMETRIC","AUTHORIZATION","BACKUP","BETWEEN","BINARY","BLANKSASNULL","BOTH","BYTEDICT","CASE","CAST","CHECK","COLLATE","COLUMN","CONSTRAINT","CREATE","CREDENTIALS","CROSS","CURRENT_CATALOG","CURRENT_DATE","CURRENT_ROLE","CURRENT_TIME","CURRENT_TIMESTAMP","CURRENT_USER","CURRENT_USER_ID","DEFAULT","DEFERRABLE","DEFLATE","DEFRAG","DELTA","DELTA32K","DESC","DISABLE","DISTINCT","DO","ELSE","EMPTYASNULL","ENABLE","ENCODE","ENCRYPT","ENCRYPTION","END","EXCEPT","EXPLICIT","FALSE","FETCH","FOR","FOREIGN","FREEZE","FROM","FULL","GLOBALDICT256","GLOBALDICT64K","GRANT","GROUP","GZIP","HAVING","IDENTITY","IGNORE","ILIKE","IN","INITIALLY","INNER","INTERSECT","INTO","IS","ISNULL","JOIN","LATERAL","LEADING","LEFT","LIKE","LIMIT","LOCALTIME","LOCALTIMESTAMP","LUN","LUNS","LZO","LZOP","MINUS","MOSTLY13","MOSTLY32","MOSTLY8","NATURAL","NEW","NOT","NOTNULL","NULL","NULLS","OFF","OFFLINE","OFFSET","OLD","ON","ONLY","OPEN","OR","ORDER","OUTER","OVERLAPS","PARALLEL","PARTITION","PERCENT","PLACING","PRIMARY","RAW","READRATIO","RECOVER","REFERENCES","REJECTLOG","RESORT","RESTORE","RETURNING","RIGHT","SELECT","SESSION_USER","SIMILAR","SOME","SYMMETRIC","SYSDATE","SYSTEM","TABLE","TAG","TDES","TEXT255","TEXT32K","THEN","TO","TOP","TRAILING","TRUE","TRUNCATECOLUMNS","UNION","UNIQUE","USER","USING","VARIADIC","VERBOSE","WALLET","WHEN","WHERE","WINDOW","WITH","WITHOUT"]);function o(n){return n.replace("T"," ").replace("Z","+00")}function i(n,e,t){let a="";for(let[o,i]of(a+=n?" (":"(",e.entries()))a+=(0===o?"":", ")+t(i);return a+")"}function r(n){if(null==n)throw Error("SQL identifier cannot be null or undefined");if(!1===n)return'"f"';if(!0===n)return'"t"';if(n instanceof Date)return'"'.concat(o(n.toISOString()),'"');if(Array.isArray(n)){let e=[];for(let t of n){if(!0===Array.isArray(t))throw TypeError("Nested array to grouped list conversion is not supported for SQL identifier");e.push(r(t))}return e.toString()}if(n===Object(n))throw Error("SQL identifier cannot be an object");let e=String(n).slice(0);if(!0===/^[_a-z][\d$_a-z]*$/.test(e)&&!1==!!a.has(e.toUpperCase()))return e;let t='"';for(let n of e)t+='"'===n?n+n:n;return t+'"'}function c(n){let e,t="";if(null==n)return"NULL";if("bigint"==typeof n)return BigInt(n).toString();if(n===Number.POSITIVE_INFINITY)return"'Infinity'";if(n===Number.NEGATIVE_INFINITY)return"'-Infinity'";if(Number.isNaN(n))return"'NaN'";if("number"==typeof n)return Number(n).toString();if(!1===n)return"'f'";if(!0===n)return"'t'";if(n instanceof Date)return"'".concat(o(n.toISOString()),"'");if(Array.isArray(n)){let e=[];for(let[t,a]of n.entries())!0===Array.isArray(a)?e.push(i(0!==t,a,c)):e.push(c(a));return e.toString()}n===Object(n)?(e="jsonb",t=JSON.stringify(n)):t=String(n).slice(0);let a=!1,r="'";for(let n of t)"'"===n?r+=n+n:"\\"===n?(r+=n+n,a=!0):r+=n;return r+="'",!0===a&&(r="E".concat(r)),e&&(r+="::".concat(e)),r}function l(n){for(var e=arguments.length,t=Array(e>1?e-1:0),a=1;a<e;a++)t[a-1]=arguments[a];return function(n,e){let t=0,a="%(%|(\\d+\\$)?[",l=RegExp(a+="ILs])","g");return n.replace(l,(n,a)=>{if("%"===a)return"%";let l=t,s=a.split("$");if(s.length>1&&(l=Number.parseInt(s[0],10)-1,a=s[1]),l<0)throw Error("specified argument 0 but arguments start at 1");if(l>e.length-1)throw Error("too few arguments");return(t=l+1,"I"===a)?r(e[l]):"L"===a?c(e[l]):"s"===a?function n(e){if(null==e)return"";if(!1===e)return"f";if(!0===e)return"t";if(e instanceof Date)return o(e.toISOString());if(Array.isArray(e)){let t=[];for(let[a,o]of e.entries())null!=o&&(!0===Array.isArray(o)?t.push(i(0!==a,o,n)):t.push(n(o)));return t.toString()}return e===Object(e)?JSON.stringify(e):String(e).toString().slice(0)}(e[l]):void 0})}(n,t)}}}]);